#+TITLE: Bitcoin Notes
#+Description: Bitcoin notes.
#+OPTIONS: \n:t
#+OPTIONS: toc:nil
#+OPTIONS: ^:nil
#+AUTHOR: Philip Glazman
#+ATTR_HTML: :textarea t :width 80

#+BEGIN_ABSTRACT
Welcome!

Bitcoin Notes is an updated list of hyperlinks, notes, and text I found to be useful while learning about Bitcoin.

A lot of these notes were written quickly or copy/pasted from sources. I am working on adding footnotes.


If you find any mistakes, [[https://twitter.com/philipglazman][Twitter DM]] is best way to reach me.
#+END_ABSTRACT
#+TOC: headlines

* Bitcoin
** Beginner Resources
   /A list of hyperlinks to get started./

   [[http://diyhpl.us/~bryan/papers2/bitcoin/][Bryan Bishop's diyhpl.us Papers]]
   [[http://diyhpl.us/wiki/transcripts/][Bryan Bihop's  diyphl.us Transcripts]]
   [[https://github.com/ChristopherA/Learning-Bitcoin-from-the-Command-Line/blob/master/README.md][Learning Bitcoin from the Command Line]]
   [[http://lopp.net/bitcoin.html][lopp.net]]
   [[https://github.com/jashmenn/bitcoin-reading-list][jashmenn's Bitcoin Reading List]]
   [[https://blog.bitjson.com/bitcoin-script-a-reading-list-656242edfa6c#.elntopnt6][A Bitcoin Script Reading List.]]
  
   Online Cources/Moocs:
   [[http://soc1024.ece.illinois.edu/teaching/ece398sc/spring2018/][soc1024 1]]
   [[http://soc1024.ece.illinois.edu/teaching/ece598am/fall2016/][soc1024 2]]
   [[https://github.com/mit-dci/mas.s62][MIT DCI online course]]
   [[https://github.com/bitcoinops/scaling-book][Scaling Bitcoin dev++]]

   
   [[https://github.com/chaincodelabs/study-groups][Chaincode Study groups]]
   [[https://github.com/chaincodelabs/bitcoin-curriculum][Chaincode Bitcoin course]]
   [[https://github.com/chaincodelabs/lightning-curriculum][Chaincode Lightning course]]
** Wallet Design
   /Wallet Design concerns all things related to wallet functionality. This mostly is application level logic./
   
   Modern bitcoin wallets are known as HD wallets or hierarchical deterministic. An HD wallet has a seed and can derive many child keys from a single key. In the early development of bitcoin, wallets would generate a new key for each receive address and then save the key to a file. This unfortunately made backups difficult and error prone. Instead, HD wallets can be backed up using a seed. The familiar 12 or 24 word mnemonic seed phrases are an artifact part of BIP39. 

*** BIP-32
    Wallets derive a number of child keys from a parent key. To prevent relying on only the key, both private and public keys are extended with an extra 32 bytes of entropy. This entropy is called the chain code.
    
    There are 2^31 child keys and 2^31 hardened child keys. The distinction is very important.

    * private parent key -> private child key = computes a child extended private key from the parent extended private key
    * public parent key -> public child key = computes a child extended public key from the parent extended public key. It is only defined for non-hardened child keys.
    * private parent key -> public child key = computes the extended public key corresponding to an extended private key (the "neutered" version, as it removes the ability to sign transactions).
    * public parent key -> private child key = not possible
 
    [[https://bitcoin.stackexchange.com/questions/62533/key-derivation-in-hd-wallets-using-the-extended-private-key-vs-hardened-derivati][Deep Dive on Extended Keys]]

    A derivation path is the descriptor for identifying the path along the BIP32 tree.
*** BIP-39
*** Wallet Standards
    Due to the flexibility of BIP32 trees, standards were created for wallet operators. Standards for the BIP32 tree allows for saner backups and easier portability of seeds between wallet services.
*** BIP-43
    The first of these standards is [[https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki][BIP-43]] which defines the first level of the BIP32 tree as the purpose field. 
*** BIP-44
    [[https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki][BIP-44]] expands on BIP-43 by specifying the coin and account levels of the BIP32 tree. In addition, the derivation path can describe whether the wallet should derive a change (or internal) address or receive (or external) address.
*** BIP-45
    [[https://github.com/bitcoin/bips/blob/master/bip-0045.mediawiki][BIP-45]]
*** BIP-47
*** SegWit

    Since SegWit, couple of changes to wallets were needed:
    [[https://bitcoincore.org/en/segwit_wallet_dev/][SegWit wallet dev guide]]
    
    One of the immediate problems that SegWit solves is mitigating transaction malleability.
*** Vaults
    [[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-August/017229.html][vaults w/o covenants]]
    [[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-August/017231.html][more by bishop]]

    [[https://blockstream.com/2019/02/04/en-standardizing-bitcoin-proof-of-reserves/][proof of reserves - blockstream]]
    
    BIP-127 proposes a standard way to do proof of reserves using a PSBT extension.
    [[https://github.com/bitcoin/bips/blob/master/bip-0127.mediawiki][link to bip]]

    There's rust implementation of a Proof-of-Reserves Client. [[https://github.com/ElementsProject/reserves][link to reserves]]

    [[https://arxiv.org/pdf/2005.11776.pdf][custody protocols using bitcoin vaults]]
  
*** Batching
    Payment batching, more [[https://github.com/bitcoinops/scaling-book/blob/master/x.payment_batching/payment_batching.md][here]], is including multiple payments inside a single transaction. 

    Variables to consider are # of inputs and # of outputs. Better to have a single input and many outputs.
    It is also nice to have a lower fee for the entire transaction. 

    Goal of batching is to lower vbytes per payment. Marginal improvmenent  after 1 input and 5 outputs.
*** Coin Selection
    [[https://medium.com/@lopp/the-challenges-of-optimizing-unspent-output-selection-a3e5d05d13ef][Challenges of coin selection by lopp]]
    [[https://iohk.io/en/blog/posts/2018/07/03/self-organisation-in-coin-selection/][iohk on coinsel]]
    [[https://bitcoin.stackexchange.com/questions/1077/what-is-the-coin-selection-algorithm][what is coinsel?]]
    [[https://diyhpl.us/wiki/transcripts/scalingbitcoin/milan/coin-selection/][murch transcript at scaling bitcoin]]
    [[http://diyhpl.us/wiki/transcripts/scalingbitcoin/tokyo-2018/edgedevplusplus/coin-selection/][edge++ transcript]]

    The naive approach would be to simply look for the smallest output that is larger than the amount you want to spend and use it, otherwise start adding the next largest outputs until you have enough outputs to meet the spend target. However, this leads to fracturing of outputs until the wallet becomes littered with unspendable “dust.”
   
    “Our idea is to have the user the option (either global or per account or
    per transaction) to choose between "maximize privacy" or "minimize fees"
    (or even maybe "minimize UTXO"

    ”Dust” refers to transaction outputs that are less valuable than three times the mininum transaction fee and are therefore expensive to spend.

    A transaction output is labeled as dust when its value is similar to the cost of spending it. Precisely, Bitcoin Core sets the dust limit to a value where spending an 2.3. Transactions 7 output would exceed 1/3 of its value. This calculation is based on the minimum relay transaction fee, a node setting that causes transactions that don’t at least include this lower bound of fee to be dropped from the memory pool, and not relayed to other nodes. With the default for the minimum relay transaction fee set to 1 000 satoshi per kilobyte, and the sizes of a P2PKH input being 148 bytes, and an output being 34 bytes, this computes to all outputs smaller or equal to 546 satoshis being considered dust by Bitcoin Core [Erha15].
   
    [[https://blog.bitgo.com/utxo-management-for-enterprise-wallets-5357dad08dd1][utxo mgmt for enterprise wallets]]
   
*** Bitcoin Core Wallet
    Bitcoin Core's wallet is always evolving. Some changes to the Bitcoin Core wallet:
    [[https://github.com/bitcoin-core/bitcoin-devwiki/wiki/Wallet-Class-Structure-Changes][Wallet Class Structure Changes]]
    [[https://gist.github.com/sipa/125cfa1615946d0c3f3eec2ad7f250a2][Sipa describing wallet changes]]
    [[http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-05-wallet-architecture/][Wallet Architecture transcripts]]
*** Descriptors 
    [[https://github.com/bitcoin/bitcoin/issues/17190][Bitcoin Issue 17190]]
    [[https://github.com/spesmilo/electrum/issues/5715][Electrum on Descriptors]]
    [[https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md][Descriptors Overview]]
    [[http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2018-10-08-script-descriptors/][coredev talk]]
   
    Implementations...
    [[https://github.com/bitcoin-core/HWI/blob/95c9387215fd534bb7a7e3e1885d92cc22457847/hwilib/descriptor.py][HWI]]
    [[https://github.com/bitcoin/bitcoin/pull/16528][Bitcoin #16528]]
    [[https://github.com/bitcoin/bitcoin/blob/08ed87e8875d72a1d8b157b67bbd431253d7db24/src/script/descriptor.cpp][Bitcoin Core]]
    [[https://github.com/bitcoin/bitcoin/blob/befdef8aee899dcf7e40aa5ea4bc1b0256381cdc/src/util/spanparsing.cpp][Bitcoin Core parsing]]
    [[https://github.com/bitcoin/bitcoin/pull/15764][Bitcoin #15764]]

*** Script
    (https://en.bitcoin.it/wiki/Contract)
    Each transaction input has a sequence number. In a normal transaction that just moves value around, the sequence numbers are all UINT_MAX and the lock time is zero. If the lock time has not yet been reached, but all the sequence numbers are UINT_MAX, the transaction is also considered final.

    Sequence numbers can be used to issue new versions of a transaction without invalidating other inputs signatures, e.g., in the case where each input on a transaction comes from a different party, each input may start with a sequence number of zero, and those numbers can be incremented independently.

    Signature checking is flexible because the form of transaction that is signed can be controlled through the use of SIGHASH flags, which are stuck on the end of a signature. In this way, contracts can be constructed in which each party signs only a part of it, allowing other parts to be changed without their involvement. The SIGHASH flags have two parts, a mode and the ANYONECANPAY modifier:

    1. SIGHASH_ALL: This is the default. It indicates that everything about the transaction is signed, except for the input scripts. Signing the input scripts as well would obviously make it impossible to construct a transaction, so they are always blanked out. Note, though, that other properties of the input, like the connected output and sequence numbers, are signed; it's only the scripts that are not. Intuitively, it means "I agree to put my money in, if everyone puts their money in and the outputs are this".
    2. SIGHASH_NONE: The outputs are not signed and can be anything. Use this to indicate "I agree to put my money in, as long as everyone puts their money in, but I don't care what's done with the output". This mode allows others to update the transaction by changing their inputs sequence numbers.
    3. SIGHASH_SINGLE: Like SIGHASH_NONE, the inputs are signed, but the sequence numbers are blanked, so others can create new versions of the transaction. However, the only output that is signed is the one at the same position as the input. Use this to indicate "I agree, as long as my output is what I want; I don't care about the others".

    There are two general patterns for safely creating contracts:
    1. Transactions are passed around outside of the P2P network, in partially-complete or invalid forms.
    2. Two transactions are used: one (the contract) is created and signed but not broadcast right away. Instead, the other transaction (the payment) is broadcast after the contract is agreed to lock in the money, and then the contract is broadcast.
    This is to ensure that people always know what they are agreeing to.
    Together, these features let us build interesting new financial tools on top of the block chain.

    It may even be that people find themselves working for the programs because they need the money, rather than programs working for the people.
   
    old oracle services...
    https://docs.oraclize.it/#home
    http://orisi.org/
    http://earlytemple.com/
    https://en.bitcoin.it/wiki/Contract#Example_4:_Using_external_state
**** Scriptless Scripts
     [[https://suredbits.com/schnorr-applications-scriptless-scripts/][SuredBits' blog on scriptless scripts]]
    
     [[https://download.wpsoftware.net/bitcoin/wizardry/mw-slides/2018-05-18-l2/slides.pdf][Poelstra ppt]]
*** Fee Estimation    
    [[https://blog.bitgo.com/the-challenges-of-bitcoin-transaction-fee-estimation-e47a64a61c72][lopp on fee estimation]]

    Fee estimation is the process of estimating a particular fee rate to use for a transaction in order to incentivize block inclusion at a particular block target.

    Supply (blocks) and demand (txns) are unpredicable.

    [[https://bitcointechtalk.com/an-introduction-to-bitcoin-core-fee-estimation-27920880ad0][John Newbery's intro to Bitcoin Core Fee Estimation]]
    [[https://bitcointechtalk.com/whats-new-in-bitcoin-core-v0-15-part-2-41b6d0493136][pt2]]
**** Outline of Newbery's post
      At broadcast, the transaction is not going to get into the next block. But rather likely the next block in 10 minutes. Block production follows Poisson distribution.

      As a result, the fee rate should be competitive not only of the current mempool but the likely mempool in ten minutes.

      Looking only at mempool does not consider lucky block runs.
     
**** Bitcoin Core's Fee Estimation
     [[https://gist.github.com/morcos/d3637f015bc4e607e1fd10d8351e9f41][High level desc of Bitcoin Core's fee estimation algorithm]]
     [[https://github.com/bitcoin/bitcoin/blob/master/src/policy/fees.h][code]]
     Bitcoin core groups transaction fee rates into buckets. Each buck is a range of fee rates. A track of block targets from 1 block to 1008 blocks is kept.

     Also, the following is recorded:
     (A) number of transactions that entered the mempool in each fee rate bucket.
     (B) for each bucket-target pair, the number of transactions that were included in a block within the target number of blocks.

     For any target-bucket pair, Bitcoin Core can find the probability that a transaction with the fee rate can be included. This is B/A.

     [[https://blog.iany.me/2020/08/bitcoin-core-fee-estimate-algorithm/][Additional overview]]
**** Mempool File Format 
     Mempool File Format can be useful for fee estimation..
     [[https://bc-2.jp/bb2019-mempool-analysis-simulation.pdf][talk by kalle]]
     Time series of a txn lifecyle until block inclusion in a small file format.

     https://github.com/kallewoof/mff

** Taproot/Schnorr
   /Notes on BIP340-342. All things concerning Schnorr, Taproot, and Tapscript./

*** Introduction
    [[https://prezi.com/view/AlXd19INd3isgt3SvW8g/][Slides from Sipa talk at SF Bitcoin Devs.]]
    [[https://github.com/bitcoinops/taproot-workshop][Taproot Workshop]]
    [[https://github.com/ajtowns/taproot-review][Taproot Review]]
    
    immediate benefit of taproot: "if you lose this key, your funds are gone" to "if you lose this key, you'll have to recover 3 of your 5 backup keys that you sent to trusted friends, and pay a little more, but you won't have lost your funds"" - anthony towns

    Notation to be used throughout (from BIP):
    * hashtag(x) notation to refer to SHA256(SHA256(tag) || SHA256(tag) || x)
    * q is taproot output key
    * p is taproot internal key

*** BIP340
    [[https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki][Link to BIP340]]
    [[https://medium.com/blockstream/reducing-bitcoin-transaction-sizes-with-x-only-pubkeys-f86476af05d7][Why only x-pubkey?]]

    Proposes standard for 64-byte Schnorr signatures.

    Why Schnorr?
    * Provable security
      Security of ECDSA rely on stronger assumptions. Schnorr signatures are provably secure.
    * Non-malleability
      Schnorr signatures are implied to be non-malleable given SUF-CMA security. ECDSA sigs are inherently malleable.
    * Linearity
      
    Encoding: Instead of DER, use fixed 64-byte format.
    Public Key Encoding: Instead of compressed 33-byte key, use 32 bytes.
    
    Interestingly, the aim of the BIP is to have the Schnorr spec completely specified. In the past, different ECDSA implementations caused issues.

    [[https://suredbits.com/introduction-to-schnorr-signatures/][SuredBits' intro to Schnorr]]

    "tweaking" involves hiding/obfuscation

    [[https://www.math.uni-frankfurt.de/~dmst/research/papers/schnorr.blind_sigs_attack.2001.pdf][security of blind discrete log signatures]]
    [[https://www.iacr.org/archive/crypto2002/24420288/24420288.pdf][generalized bday problem]]

    [[https://medium.com/blockstream/reducing-bitcoin-transaction-sizes-with-x-only-pubkeys-f86476af05d7][x-only pubkeys]]
    [[https://eprint.iacr.org/2019/023.pdf][lattice attacks against weak ECDSA]]

    A schnorr signature is defined as the following:
    S = R + H(x(R)|P|m) * P
    where R is the Nonce point (k*G)
    
    To save 32 bytes, only the x value of R is provided by the signer.
    The verifier can computer the y-value.

    One of the y-coordinates is even while the other is odd.

    Proposal constraints k such that y-value of R is quadratic residue module SECP256K1_FIELD_SIZE.
    Quadaratic residue is having a square root modulo the field size.

    If a randomly generated nonce k does not yield a valid nonce point R, then the signer can negate k to obtain a valid nonce.
    
*** BIP341
    [[https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki][Link to BIP341]]

    Proposes new SegWit v1 output type with spending rules based on Taproot, Schnorr, and merkle branches.

    BIP claims no new security assumptions are added.

    The aims of the output type is to improve privacy, efficiency, and flexibility of Bitcoin script. This is especially useful in minimizing how much information is shown on the blockchain regarding the spendability conditions. Additionally, a few bug fixes are included.
    
    
    The BIP is very selective in the technologies that are included. Many are swept for later review in order to reduce complexity of review as well as prevent immature technology from weighind down ready technology.

    From the BIP document, the following technologies compose the proposal:
    * Merkle Branches: Reveal the actual executed part of the script.
    * Taproot: Merge pay-to-pubkey and pay-to-scripthash policies making outputs spendable by either indistiguishable.
      As long as key-based spending path is used for spending, it is not revealed whether a script path was permitted as well.
      An assumption is made that most outputs can be spent by all parties agreeing. Schnorr permits key aggregation[fn:1].

    Key aggregation allows a public key to be constructed from multiple participant keys. Indistinguishable from single-party.
    * Batch validation is permited with schnorr signatures.
    * Every merkle tree has an associated version allowing for new script versions to be introduced via soft fork. Unused 'annex' in the witness can also be used.
    * New Signature Hashing Algorithm includes amount and ScriptPubKey in message. And uses tagged hashes.
    * The public key is directly included in the output. 

    BIP can be informally summarized in the following way:
    : a new witness version is added (version 1), whose programs consist of 32-byte encodings of points Q. Q is computed as P + hash(P||m)G for a public key P, and the root m of a Merkle tree whose leaves consist of a version number and a script. These outputs can be spent directly by providing a signature for Q, or indirectly by revealing P, the script and leaf version, inputs that satisfy the script, and a Merkle path that proves Q committed to that leaf. All hashes in this construction (the hash for computing Q from P, the hashes inside the Merkle tree's inner nodes, and the signature hashes used) are tagged to guarantee domain separation.
    
    A taproot output is a native SegWit output with version number 1 and a 32-byte witness program.
 
    Every taproot output corresponds to a combination of a single public key condition (internal key), and zero or more general conditions encoded in scripts in a tree.

    General guidelines for construction and spending Taproot outputs:
    * Better to split scripts with conditionls (OP_IF) into multiple scripts in the tree...each corresponding to one execution path.
    * When a single condition requires signautres from multiple keys, key aggregation MuSig can be used.
    * Most likely key to be used should be the internal key. If no such condition exists, worthwhile adding one that consists of an aggregation of all keys. This is an "everyone agrees" branch. Else just pick an internal key using a point wi unknown discrete logarithm. See BIP for example.
    * If no script conditions needed, an output key should commit to an unspendable script path instead. See BIP for how to achieve this.
    * Remaining scripts should be organized into leaves. Huffman tree.
    * Binary tree leaves are (leaf_version, script) tuples.

    Q=P+H(P,m)*G
    where P is public key and m is merkle root of a MAST.

    [[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-January/015614.html][switchable scripting]]
*** BIP342
    [[https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki][Link to BIP342]]
    
    Proposes semantics of the scripting system described in BIP341.
    
    Includes improvements to schnorr signatures, batch validation, and signature hash.
    
    OP_CHECKSIG and OP_CHECKSIGVERIFY are modified to verify schnorr signatures.
    OP_CODESEPARATOR simplified.

    OP_CHECKMULITSIG and OP_CHECKMULTISIGVERIFY are disabled. OP_CHECKSIGADD is introduced to make multisigs batch-verifiable.

    A potential malleability vector is eleminated by requiring MINIMALIF. Using a non-standard represetentation of true for OP_IF is now considered invalid as a violation of consensus rules.

    OP_SUCCESS opcodes allows introducing new opcodes cleanly than through OP_NOP.

    Tapscript can be upgraded through soft forks by defining unknown key types. For example, adding a new hash_types or signature algorithms.
   
*** MuSig
    Schnorr multi-signature scheme.

    Blockstream announcing [[https://blockstream.com/2019/02/18/en-musig-a-new-multisignature-standard/][MuSig.]]
 
    [[https://eprint.iacr.org/2018/068.pdf][actual whitepaper]]
    [[https://suredbits.com/schnorr-applications-musig/][SuredBits' blog on musig]]
    
    [[https://medium.com/blockstream/insecure-shortcuts-in-musig-2ad0d38a97da][Insecure Shortcuts in MuSig]]
    [[https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6][MuSig-DN: Deterministic Nonces]]

    [[https://bitcoin.stackexchange.com/questions/91534/musig-signature-interactivity][MuSig Interactivity]]

**** MuSig2
     Exchanging nonce commitments is the subject of the [[https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6][MuSig-DN paper]].

     Nonce commitment exchange can be removed by generating the nonce deterministically from the signers' public keys and message.
     Providing a non-interactive zk proof that the nonce was generated deterministically along with the nonce.

     The MuSig2 scheme has a two round signing protocol w/o the need for a sk proof.
     Also, the first round of the nonce exchange is done at key setup time.

     Therefore, there are two variants: interactive setup and non-interactive setup.

     [[https://bitcoinops.org/en/newsletters/2020/10/21/][BitcionOps explains MuSig2]]

     [[https://eprint.iacr.org/2020/1261][MuSig2]]
*** SIGHASH_ANYPREVOUT
    [[https://github.com/ajtowns/bips/blob/bip-anyprevout/bip-anyprevout.mediawiki][proposed bip]]
    
    a new type of public key for tapscript (bip-tapscript) transactions. It allows signatures for these public keys to not commit to the exact output being spent. This enables dynamic binding of transactions to different UTXOs, provided they have compatible scripts.

    Allows dynamic rebinding of a signed transaction to another previous output of the same value

** Mining
   /All things Bitcoin mining./

*** Introduction    
   [[https://stephanlivera.com/episode/128/][Excellent podcast on mining]]

   cgminer is open source miner for ASIC/FPGA miner. Lots of companies forked off this original miner.
   https://github.com/ckolivas/
   
   [[https://bitcointalk.org/index.php?topic=2135429.msg21352028][channel payouts in mining]]

*** GetBlockTemplate
    Getblocktemplate: bitcoin core <-> pool server
*** Stratum
    Stratum: pool server <-> asic controller 
    [[https://slushpool.com/help/topic/stratum-protocol/][Stratum Protocol documentation]]
    The design of the Stratum protocol requires pool operators to build and distribute block templates to their clients.
*** StratumV2
*** Betterhash
   * Work protocol: bitcoin
   * core <-> mining proxy
   * Work protocol: mining proxy/bitcoin core <-> asic controller
   * Pool protocol: pool server <-> mining proxy 
   [[https://github.com/TheBlueMatt/bips/blob/betterhash/bip-XXXX.mediawiki][link to bip]]
   [[https://medium.com/hackernoon/betterhash-decentralizing-bitcoin-mining-with-new-hashing-protocols-291de178e3e0][betterhash overview]]
*** Compact Blocks
    [[https://bitcoincore.org/en/2016/06/07/compact-blocks-faq/][faq for compact blocks]]
    Compact block relay, BIP152, is a method of reducing the amount of bandwidth used to propagate new blocks to full nodes.

    Using simple techniques it is possible to reduce the amount of bandwidth necessary to propagate new blocks to full nodes when they already share much of the same mempool contents. Peers send compact block “sketches” to receiving peers.

** P2P
   /P2P layer of Bitcoin./
   For the Bitcoin network to remain in consensus, the network of nodes must not be partitioned. So for an individual node to remain in consensus with the network, it must have at least one connection to that network of peers that share its consensus rules.

   [[https://gist.github.com/sdaftuar/c2a3320c751efb078a7c1fd834036cb0][partition resistance]]
   
** Lightning Network
   /Lightning Network and related off-chain protocols//
   [[https://github.com/lnbook/lnbook][Master Lightning Book]]
   [[http://dev.lightning.community/overview/][ln overview]]
   [[https://github.com/t-bast/lightning-docs/blob/master/lightning-txs.md][ln zero to hero]]
   [[https://github.com/t-bast/lightning-docs][t-bast's notes]]

   Lightning Network is a scaling solution to keep most transactions off-chain while leveraging the security of the bitcoin chain as an arbitration layer. There are several concepts to review before jumping into the domain. We will start small by covering lightning primitives, then apply these primitives to describe the Lightning Network.

   
   Payments channels is a construct between two parties that commit funds and pay each other by updating a balance redeemable by either party. Moving funds between each part is near instant. Channels have a total capacity that is established by the on-chain funding transaction. Additionally, each party in the channel has their own balance. For example, a channel between Alice and Bob can have a 1 BTC capacity, but 30% of the bitcoin is owned by Bob. For Alice, this means that her local_balance is 0.7 BTC while the remote_balance (Bob's balance) is 0.3 BTC.

   To create the payment channel construction, a funding transaction is created on-chain. Any updates to the channel involves updating the commitment transaction.

   Hash Time-Locked Contracts (HTLCs) allow transactions to be sent between parties who do not have a direct channels by routing it through multiple hops, so anyone connected to the Lightning Network is part of a single, interconnected global financial system.

   Payment channels are the main workhorse of the Lightning Network. They allow multiple transactions to be aggregated into just a few on-chain transactions. In the vast majority of cases, someone only needs to broadcast the first and last transaction in the channel.
   * The Funding Transaction creates the channel. During this stage, funds are sent into a multisig address controlled by both Alice and Bob, the counterparties to the channel. This address can be funded as a single-payer channel or by both Alice and Bob.
   * The Closing Transaction closes the channel. When broadcast, the multisig address spends the funds back to Alice and Bob according to their agreed-upon channel amount.

   channel updates
   * In between the opening and closing transactions broadcast to the blockchain, Alice and Bob can create a near infinite number of intermediate closing transactions that gives different amounts to the two parties.
   * For example, if the initial state of the channel credits both Alice and Bob with 5BTC out of the 10BTC total contained in the multisig address, Alice can make a 1BTC payment to Bob by updating the closing transaction to pay 4BTC/6BTC, where Alice is credited with 4BTC and Bob with 6BTC. Alice will give the signed transaction to Bob, which is equivalent to payment, because Bob can broadcast it at any time to claim his portion of the funds. 
     * To prevent an attack where Alice voids her payment by broadcasting the initial state of 5BTC/5BTC, there needs to be a way to revoke prior closing transactions. Payment revocation roughly works like the following.
     * Alice must wait 3 days after broadcasting the closing transaction before she can redeem her funds. During this time, Bob is given a chance to reveal a secret that will allow him to sweep Alice’s funds immediately. Alice can thus revoke her claim to the money in some state by giving Bob the secret to the closing transaction. This allows Bob to take all of Alice’s money, but only if Alice attest to this old state by broadcasting the corresponding closing transaction to the blockchain.

  Payment channels & revocable transactions
  [[https://paychan.github.io/bitcoin-payment-channels-taxonomy/][great graphical overview]]

  txn:
  Bob’s signature and a relative timelock (Bob’s spend branch); or
  Alice’s signature and a secret revocation hash provided by Bob (Alice’s revocation branch).
   

  usually have multiple utxos. Once bob reveals his secret, alice can collect her spend TXO and rTXO.

  revocable transaction script_pub_key: 
  OP_IF # Bob's spend branch - after the revocation timeout duration, Bob can spend with just his signature
    <TXO revocation timeout duration> OP_CHECKSEQUENCEVERIFY OP_DROP
    <Bob's public key>
  OP_ELSE # Revocation branch - once the revocation pre-image is revealed, Alice can spend immediately with her signature
    OP_HASH160 <h(rev)> OP_EQUALVERIFY OP_DROP
    <Alice's public key>
  OP_ENDIF
  OP_CHECKSIG

  recovcation keys used base points and blinding key. similar to bip32, keys derived using base key.
  
  [[https://rusty.ozlabs.org/?p=450][revocable transactions]]
  [[https://rusty.ozlabs.org/?p=462][HTLCs]]

  [[https://docs.google.com/presentation/d/1TyF0W3cZbkz4SyZG9qY7Is2pytC1GwSvs9KRKmYblFk/edit#slide=id.p][enterprise lightning presentation]]
*** BOLTs
    [[https://www.youtube.com/watch?v=Ysj2yobFMF4][great overview of BOLT by Jim Posen]]
    [[https://www.youtube.com/watch?v=toarjBSPFqI][how onion routing works with HTLCs]]

    [[https://commons.wikimedia.org/wiki/File:Introduction_to_the_Lightning_Network_Protocol_and_the_Basics_of_Lightning_Technology_(BOLT_aka_Lightning-rfc).pdf][presentation by Rene]]

    BOLT is the Basics of Lightning Technology.

    The BOLT repo found [[https://github.com/lightningnetwork/lightning-rfc][here]] describes the specification for the Lightning Network.

**** BOLT #0
     Provides a basic glossary defining terminology that is used throughout the rest of the specification.
**** BOLT #1
     Describes the base message protocol including the TLV format and the setup messages.

     TLV is Type-Length-Value.

     Funny enough, the unicode code point for lightning is 0x2607. In decimal, 9735 which is also the default TCP port.
**** BOLT #2
     Contains peer channel protocol lifecycle.

     A channel_id is used to identify a channel. channel_id = XOR(funding_txid, funding_output_index)

     Before a channel is created, a temporary_channel_id is used which acts a nonce. This nonce is local and can be duplicate across the rest of the protocol.

***** Channel Establishment
      
      +-------+                              +-------+
      |       |--(1)---  open_channel  ----->|       |
      |       |<-(2)--  accept_channel  -----|       |
      |       |                              |       |
      |   A   |--(3)--  funding_created  --->|   B   |
      |       |<-(4)--  funding_signed  -----|       |
      |       |                              |       |
      |       |--(5)--- funding_locked  ---->|       |
      |       |<-(6)--- funding_locked  -----|       |
      +-------+                              +-------+
      - where node A is 'funder' and node B is 'fundee'

      An outpoint is provided to B at step 3.
      

***** Channel Close

       +-------+                              +-------+
       |   | --(1)-----  shutdown  -------> |   |
       |   | <-(2)-----  shutdown  -------- |   |
       |   |                                |   |
       |   | <complete all pending HTLCs>   |   |
       | A | ...                            | B |
       |   |                                |   |
       |   | --(3)-- closing_signed  F1---> |   |
       |   | <-(4)-- closing_signed  F2---- |   |
       |   | ...                            |   |
       |   | --(?)-- closing_signed  Fn---> |   |
       |   | <-(?)-- closing_signed  Fn---- |   |
       +-------+                              +-------+ 

***** Normal Operation
      Once both nodes have exchanged funding_locked, the channel is used to make payments with HTLCs.
**** BOLT #3
     Describes transaction and script formats.
**** BOLT #4
**** BOLT #5
     Channels can end with a mutual close, unilateral close, or a revoked transaction close.

     In a mutual close, local and remote nodes agree to close. They generate a closing transaction.

     In a unilateral close, one side publishes its latest commitment transaction.

     In a revoked transaction close, one party is cheating and publishes an oudated commitment transaction.

     A commitment transaction has up to six types of outputs:
     1. local node's main output: Zero or one output, to pay to the local node's delayed_pubkey.
     2. remote node's main output: Zero or one output, to pay to the remote node's delayed_pubkey.
     3. local node's anchor output: one output paying to the local node's funding_pubkey.
     4. remote node's anchor output: one output paying to the remote node's funding_pubkey.
     5. local node's offered HTLCs: Zero or more pending payments (HTLCs), to pay the remote node in return for a payment preimage.
     6. remote node's offered HTLCs: Zero or more pending payments (HTLCs), to pay the local node in return for a payment preimage.

     If the local node publishes its commitment transaction, it will have to wait to claim its own funds, whereas the remote node will have immediate access to its own funds. 
**** BOLT #7    
     P2P
**** BOLT #8
**** BOLT #9
**** BOLT #10
**** BOLT #11
     Invoice spec.
**** WIP: BOLT #12
     BOLT 12 describes a new invoice format and flow called Offers.

     The Draft of the PR can be found [[https://github.com/lightningnetwork/lightning-rfc/pull/798][here]].

     The flow described is the following:
     1. Receiver publishes an offer.
     2. Payer requests a new unique invoice over LN using the offer.
     3. Receiver responds with a unique invoice.
     4. Payer pays the invoice.

     There are a number of improvements over BOLT11.
    
     Payment proof is designed to allow the payer to prove that they were the unique payer.

     Merkle tree is used to be able to prove only specific fields of the invoice, not the enture invoice!
     
     Some offers are periodic, meaning that payments are expected on a recurring period. This allows for new applications that require subscription-based payments. 
*** Implementations
    There are several implementations following the BOLT specification.
**** LND
     [[http://diyhpl.us/wiki/transcripts/sf-bitcoin-meetup/2018-04-20-laolu-osuntokun-exploring-lnd0.4/][Exploring LND 0.4]]
     [[http://diyhpl.us/wiki/transcripts/sf-bitcoin-meetup/2019-05-02-conner-fromknecht-lnd-0.6-beta/][LND 0.6-Beta]]
*** anecdotal example
   Suppose Alice has a channel with Bob, who has a channel with Carol, who has a channel with Dave: A<->B<->C<->D. How can Alice pay Dave?
   Alice first notifies Dave that she wants to send him some money.
   In order for Dave to accept this payment, he must generate a random number R. He keeps R secret, but hashes it and gives the hash H to Alice.

   Alice tells Bob: “I will pay you if you can produce the preimage of H within 3 days.” In particular, she signs a transaction where for the first three days after it is broadcast, only Bob can redeem it with knowledge of R, and afterwards it is redeemable only by Alice. This transaction is called a Hash Time-Locked Contract (HTLC) and allows Alice to make a conditional promise to Bob while ensuring that her funds will not be accidentally burned if Bob never learns what R is. She gives this signed transaction to Bob, but neither of them broadcast it, because they are expecting to clear it out later.
   Bob, knowing that he can pull funds from Alice if he knows R, now has no issue telling Carol: “I will pay you if you can produce the preimage of H within 2 days.”
   Carol does the same, making an HTLC that will pay Dave if Dave can produce R within 1 day. However, Dave does in fact know R. Because Dave is able to pull the desired amount from Carol, Dave can consider the payment from Alice completed. Now, he has no problem telling R to Carol and Bob so that they are able to collect their funds as well.

   Alice knows that Bob can pull funds from her since he has R, so she tells Bob: “I’ll pay you, regardless of R, and in doing so we’ll terminate the HTLC so we can forget about R.” Bob does the same with Carol, and Carol with Dave.

   Now, what if Dave is uncooperative and refuses to give R to Bob and Carol? Note that Dave must broadcast the transaction from Carol within 1 day, and in doing so must reveal R in order to redeem the funds. Bob and Carol can simply look at the blockchain to determine what R is and settle off-chain as well.

*** Lightning Conf 2019 Berlin
   [[https://www.electrum.org/talks/lightning/presentation.html#slide1][electrum slides on lightning]]
   Circular routes: send to self.
   Suggestions
     - do not accept random peers
     - disallow invoices to blacklisted pubkeys

   Command line tools
     -  LNDmanage by @bitromortac
     -  Balance of Satoshis by @alexbosworth
     -  Rebalance-LND by @C-Otto

    Make Me an Offer (Bolt 12) introduced.

    LSAT
    * Macaroon - cryptographic bearer credential
    * Delegation possible
    * Chained HMAC construction
        * Secret root used to derive all others
    * Fine grained permission

    Hedging the Chain
    * Bitcoin fee market
    * “Every biz using the blockchain is inherently short blockchain fees”
    * Derivatives traditionally used as a hedge
    * Corn farmers inherently long corn
    * They short corn futures as a hedge

    Liquidity
    * No pairwise trades
    * different sources of liquidity is not the same
    * Set outbound liquidity to the same fee
    * Varied inbound liquidity
    * Make liquidity a pairwise market
    * External settlement mechanisms
    * Circular rebalancing

    Attacks
    * Set min chan size …too many channels causes performance issues
    * Create a bunch of hold invoices and drain balance
    * Stealing free fees, someone sets up intermediate node between invoice and collects fees.


    [[http://diyhpl.us/wiki/transcripts/stanford-blockchain-conference/2019/htlcs-considered-harmful/][htlcs are harmful]]

*** Discrete Log Contracts
    [[https://medium.com/@gertjaap/discreet-log-contracts-invisible-smart-contracts-on-the-bitcoin-blockchain-cc8afbdbf0db][intro]]
    
*** Security
    [[https://medium.com/@devrandom/securing-lightning-nodes-39410747734b][securing lightning nodes by devrandom]]
    [[https://gitlab.com/lightning-signer][link to the lightning-signer project on GitLab]]
    [[https://suredbits.com/lightning-101-for-exchanges-security-part-3-private-key-management/][key mgmt]]

    [[https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002735.html][blackmail attack]]
**** LSAT
     Lightning Service Authentication Token
     [[https://docs.google.com/presentation/d/1QSm8tQs35-ZGf7a7a2pvFlSduH3mzvMgQaf-06Jjaow][lsat talk]]

     using macaroon based bearer API credential with lightning network payment

**** Key management
     [[https://docs.google.com/presentation/d/1_-FF0U2AXuhBxEzW9J_IrYxvRi1SS2MYwJl0QeIcqbI][talk on key mgmt]]
     need onchain hot wallet to open channels (only need once)

     1 of 2 keys must be hot for the funding transaction.
     If counterparty gets key, funds are lossed. If 3rd party gets it, they must collude.

     Commitment secret: must be hot.
     Used to generate "local_pubkey" and "remote_pubkey"
     Used to derive subsequent secrets and public keys.
     If leaked, peer can steal all money in commitment txn.

     Revocation basepoint secret: can be cold.
     Used to claim peer funds if they try to cheat.
     Can be cold if accessible before "to_self_delay"
     
     If your counterparty gets access to this key, they can claim their funds in their to_local output immediately by circumventing the locktime

     Payment basepoint secret: claim money from the "to_remote" output on peer commitment txn.
     can be cold
     if peer gets access to this key, all funds can be taken in the "to_remote".

     Delayed Payment Basepoint Secret: claim money on "to_local" output of commitment txn. can be cold.

     HTLC Basepoint Secret: secret needed to sign for HTLCs. must be hot.


   hosted channels  
   [[https://gist.github.com/btcontract/d4122a79911eef2620f16b3dfe2850a8][gist on hosted channels]]
   interesting idea but need to look more into security assumptions..

*** Routing
    Routing involves routing a lightning payment through either a public or private channel.

    Routing is generally constructed for a specified payment amount.
    Other considerations, however, includes value of open channels, decision to make new channels, re-balancing decisions, multi-path payments or multi-part payments (MMP, formerly AMP).

    [[https://medium.com/coinmonks/amount-independent-payment-routing-in-lightning-networks-6409201ff5ed][amount independent routing]]

    One of problem in routing is payment privacy. Two proposals to increase the privacy of paymnet senders and recipients are rendevous routing and route blinding.
    
**** Rendezvous Routing
     Rendevous routing is a [[https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-November/001498.html][proposal]] aimed to protect the privacy of payments on the lightning network. In the initial proposal, an argument is made that private channels should not be revealed to payers. The solution is to have the payee choose one or more routes from certain third-party nodes on the public network to himself, and pass sphinx-encryped blogs for those routes to the payer. Then, the payer complets the route by finding routes from himself to the selected third-party nodes.

    [[https://github.com/lightningnetwork/lightning-rfc/wiki/Rendez-vous-mechanism-on-top-of-Sphinx][Rendezvous mechanism on top of sphinx]]

**** Route Blinding
     Route Blinding is currently a [[https://github.com/lightningnetwork/lightning-rfc/blob/route-blinding/proposals/route-blinding.md][proposal]] that aims to provide recipient anonymity by blinding an arbitrary amount of hops at the end of an onion path. Like rendezvous routing, this proposal is aimed and hiding the final portion of the route from the sender. The recipient chooses an "introduction point" and a route to himself from that point. The recipient blinds each node and channel for that route with ECDH. This blinded route and a hop-binding secret are included in the invoice.
 
**** Upfront Payments
     Jamming attacks are possible where an attack can delay a payment resolution and therefore lock bitcoin along a route for a period of time. This attack is described [[https://lists.linuxfoundation.org/pipermail/lightning-dev/2015-August/000135.html][here]].

     Fidelity Bonds are a solution to 
*** Trampoline Payments
    Lightning network currently relies on source routing where sender calculates the route. Sender needs to maintain graph state.

    Trampoline payments is a new suggested way of outsourcing that aims at having lite clients outsourcing the route computation to trampoline nodes, nodes of higher Memory, bandwidth and computation power.

    [[https://bitcointechweekly.com/front/outsourcing-route-computation-with-trampoline-payments/][design decisions on trampoline routing]]

*** HTLCs
    HTLCs..Hashed Time Lock Contracts.

    The initiator of a Lightning channel pays the closing fee. Lots of HTLCs = large fee. See [[https://twitter.com/joostjgr/status/1310584596174643200][thread]].
    
    [[https://twitter.com/joostjgr/status/1311608861955158019][Thread on free HTLC forwarding]]

    An interesting idea to handling the edge cases around HTLCs is to have a firewall. An [[https://github.com/lightningequipment/circuitbreaker][example]].

*** PTLCs
    Payment Points
    [[https://suredbits.com/payment-points-and-barrier-escrows/][excellent SuredBits blog on PTLCs]]
    
*** Static/Send/Spontaneous/Push Payments
    Wow, lots of names for an overlapping concept.

    [[https://github.com/lightningnetwork/lightning-rfc/pull/798][Offers]]
    [[https://github.com/lightningnetwork/lightning-rfc/pull/798][Static Payments]]
    [[https://github.com/lightningnetwork/lightning-rfc/issues/644][Push Invoices]]
*** Future
    [[https://blog.theabacus.io/lightning-network-2-0-b878b9bb356e][challenges and opportunites for ln 2]]

    [[https://medium.com/@antoine.riard/why-we-may-fail-lightning-ee3692de1a55][Why We Fail Lightning]]
*** revocation_secret_derivation
    TODO
*** Operations
    The challenges of operating a lightning node deserves its own section. The lightning domain is distinct from on-chain bitcoin due to its own security assumptions, state changes, and end-user experience.

    The most immediate concern is backup maintance. With on-chain bitcoin, one can is familiar with BIP39 mnemonic seed phrases as the ultimate backup for bitcoin. In lightning, the backup file is responsible for channels. Do *not* take backups of channel state itself. Inaccurate or revoked channel state is can lead to a justice transaction and punishment (loss of all funds in the channel). As a result, backups are tricky in lightning.

    Static channel backups (SCBs) are the best backups for lightning node operators. The backups are called static because they are only obtained once - when the channel is created. Afterwards, the backup is valid until the channel is closed. A SCB allows a node operator to recover funds that are fully settled in a channel. Fully settled funds are bitcoin in commitment outputs, but not HLTCS.

    [[https://github.com/lightningnetwork/lnd/blob/master/docs/recovery.md][LND Recovery Documentation]]
    [[https://github.com/lightningnetwork/lnd/pull/2313][LND PR#2313]]
    [[https://gist.github.com/alexbosworth/2c5e185aedbdac45a03655b709e255a3][Automating channel backups for LND]]
    [[https://api.lightning.community/#subscribechannelbackups][Subscribe to channel backups for LND]]

    In addition to backups, channel management is a large area of focus. A node operator wants to be connected to reliable and honest peers. Factors to consider are uptime, balance, and cost of rebalancing. It is convenient to create a list of decent nodes and maintain a relationship with them. For inbound liquidity, swaps can be used or swap services like Lightning Labs Loop. Loop can be used to refill channels. Managing incoming channel requests can be important in order to prevent undesirable peers. For example, setting a threshold for channel capacity can prevent dust limit problems in the future. It is better to have fewer channels that are well capitalized than many channels with poor capcity. 

    Watchtowers can be used to monitor private nodes.
    
*** Limitations
    
** Privacy
   /Privacy and techniques used in chain-analysis./
   [[https://en.bitcoin.it/wiki/Privacy][privacy wiki]]

   [[https://www.youtube.com/watch?v=peT_9XF2L04][snowball presentation at ldn bitdevs]]

   common input hueristic: “different public keys used as inputs to a transaction as being controlled by the same user”
   [[https://cseweb.ucsd.edu/~smeiklejohn/files/imc13.pdf][original paper on blockchain analysis]]

   [[https://github.com/6102bitcoin/CoinJoin-Research][coin join wiki]]

*** CoinJoins
    "So a world where "basically everyone uses CoinJoin" is cool for privacy, but could end up pretty bad for scalability, because these transactions are in addition to the normal payments."  - waxwing

**** PayJoin
     [[https://joinmarket.me/blog/blog/payjoin/][payjoin by waxwing]]
     PayJoin is coinjoin + payment

     "Let Bob do a CoinJoin with his customer Alice - he'll provide at least one utxo as input, and that/those utxos will be consumed, meaning that in net, he will have no more utxos after the transaction than before, and an obfuscation of ownership of the inputs will have happened without it looking different from an ordinary payment."

     "the main point is with PayJoin - we break the heuristic without flagging to the external observer that the breakage has occurred." ... unlike coinjoins

     "snowball effect" ... payjoin/p2ep reduces utxo set and receiver's utxo gets bigger after each payment txn.

     who pays for the fee?
     "every payment to the merchant creates a utxo, and every one of those must be paid for in fees when consumed in some transaction. "

     real world implementation is [[https://samouraiwallet.com/stowaway][samourai wallet]]

     [[https://gist.github.com/AdamISZ/4551b947789d3216bacfcb7af25e029e][join market]]

**** Pay To EndPoint (P2EP)
     [[https://blockstream.com/2018/08/08/en-improving-privacy-using-pay-to-endpoint/][p2ep blockstream]]
     "The basic premise of P2EP is that both Sender and Receiver contribute inputs to a transaction via interactions coordinated by an endpoint the Receiver presents using a BIP 21 compliant URI."

     Steps:
     1. Receiver generates a BIP 21 formatted URI with an additional parameter that specifies their P2EP endpoint. 
     2. The Sender initiates interaction with the Receiver by confirming that the endpoint provided is available. If not, the transaction is broadcast normally, paying to the Receiver’s BIP 21 regular Bitcoin address. If the Receiver’s endpoint is available, the Sender provides a signed transaction to the Receiver as proof of UTXO ownership.
     3. The Receiver then sends a number of transactions to the Sender for them to sign. Out of these transactions, only one includes a UTXO that is actually the owned by the Receiver, the rest can be selected from the pool of spendable UTXOs.
     4. Receiver obtains a signed transaction that corresponds to their UTXO they can sign and broadcast the transaction, which will now contain inputs from both the Sender and the Receiver.
     
     Example: 
     If Alice wants to pay Bob 1 BTC:
     1. Alice inputs 3 BTC to a transaction.
     2. Bob inputs 5 BTC to the same transaction.
     3. Alice receives 2 BTC (as her change).
     4. Bob receives 6 BTC (as his change, plus the 1 BTC payment from Alice).

     Disadvantages:
     Receiver and Sender must be online. Interactive.
     More Cons/Pros listed in blogpost.

*** BIP-79
    [[https://github.com/bitcoin/bips/blob/master/bip-0079.mediawiki][link to bip]]

*** CoinSwaps
    [[https://bitcointalk.org/index.php?topic=321228.0][maxwell on coinswaps]]
    [[https://joinmarket.me/blog/blog/coinswaps/][waxwing on coinswaps]]
    
    "We can use a cryptographic commitment scheme to create atomicity that binds two, independent Bitcoin transactions"

    Make a random x, hash it. Make a p2sh output that is spendable with proving hash(x) is hash in scriptpubkey and pubkey owns output.
    
    Other party can see x and then solve for their p2sh with their pubkey.

    [[https://github.com/AdamISZ/CoinSwapCS/issues/25#issuecomment-311281096][great explainer on cross-chain swaps]]

    problem here is that x is revealed and a connection exists between both parties.

    HTLCs with presigned transactions can help avoid revealing x.
    [[https://en.bitcoin.it/wiki/Hash_Time_Locked_Contracts][htlcs wiki]]

    "An advantage of Coinswap over Coinjoin is a potentially bigger anonymity set (a lot more could be said)"
    
    [[https://github.com/AdamISZ/CoinSwapCS/blob/master/docs/coinswap_new.pdf][visual guide]]

    [[https://github.com/AdamISZ/CoinSwapCS][implementation]]

    [[https://gist.github.com/chris-belcher/9144bd57a91c194e332fb5ca371d0964#design-for-a-coinswap-implementation-for-massively-improving-bitcoin-privacy-and-fungibility][new coinswap implementation]]

*** TumbleBit
    [[https://joinmarket.me/blog/blog/tumblebit-for-the-tumble-curious/][waxwing on tumblebit]]
    [[https://eprint.iacr.org/2016/575][original paper]]
    
    "A blind signature is allows a central authority to sign data which is hidden from them"

    "Chaumian cash" is a central mint authorised to blind-sign transfers of this cash
   
    " At a very high level, it's using commitments - I promise to have X data, by passing over a hashed or encrypted version, but I'm not yet giving it to you - and interactivity - two-way messaging, in particular allowing commitments to occur in both directions."

    [[https://en.wikipedia.org/wiki/Blind_signature][blind signatures]]

*** SNICKER
    [[https://gist.github.com/AdamISZ/2c13fb5819bd469ca318156e2cf25d79][link to bip]]

    SNICKER (Simple Non-Interactive Coinjoin with Keys for Encryption Reused)

    allowing the creation of a two party coinjoin without any synchronisation or interaction between the participants. 

*** PaySwap
    [[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-January/017595.html][dev mailing list]]

    

*** More Cryptography
**** Adaptor Signatures
     [[https://github.com/ElementsProject/scriptless-scripts/blob/master/md/atomic-swap.md][explainer using atomic swaps]]
    "An "adaptor signature" is a not a full, valid signature on a message with your key, but functions as a kind of "promise" that a signature you agree to publish will reveal a secret, or equivalently, allows creation of a valid signature on your key for anyone possessing that secret."
**** Schnorr
     [[https://joinmarket.me/blog/blog/liars-cheats-scammers-and-the-schnorr-signature/][waxwing on schnorr sigs]]
     [[https://joinmarket.me/blog/blog/flipping-the-scriptless-script-on-schnorr/][scriptless scripts and schnorr]]

     [[https://joinmarket.me/blog/blog/multiparty-s6/][multiparty schnorr coinshuffle]]
**** Ring Signatures
     [[https://joinmarket.me/blog/blog/ring-sig][waxwing on ring sigs]]
     

*** Chain Analysis
     Peel chains are strings of transactions commonly used for money laundering, in which entities send funds through several wallets in quick succession, usually breaking off small amounts to cash out at each step and sending the majority on to the next wallet.

** Security
   /Security related information./
   [[https://www.youtube.com/watch?v=UDbl-2gk7n0][everything is broken]]

   [[https://blog.bitmex.com/build-systems-security-bitcoin-is-improving/][bitcoin is improving]]

   [[https://link.springer.com/chapter/10.1007/978-3-030-00470-5_29][identifying key leakage in bitcoin]]
*** Hardware Wallets
    [[https://thecharlatan.github.io/List-Of-Hardware-Wallet-Hacks/][list of hardware wallet hacks]]
** Bitcoin Core 
   /Notes on Bitcoin Core architecture and development./
*** Debugging
    [[https://gist.github.com/fjahr/2cd23ad743a2ddfd4eed957274beca0f][debug wiki]]

    LogPrintf("")
    cat debug.log | grep @@@
    
    lldb src/bitcoind

    unit tests in src/test/ using BOOST lib test framework.

    Run just one test file: src/test/test_bitcoin --log_level=all --run_test=getarg_tests
    Run just one test: src/test/test_bitcoin --log_level=all --run_test=*/the_one_test

    Logging from unit tests...
    BOOST_TEST_MESSAGE("@@@");

    functional tests in test/functional using python
    --loglevel=debug
    self.log.debug("bar")

    Use --tracerpc to see the log outputs from the RPCs of the different nodes running in the functional test in std::out.

    [[https://github.com/bitcoin/bitcoin/blob/master/test/README.md][on tests]]
    [[https://github.com/bitcoin/bitcoin/blob/master/src/test/README.md][on unit tests]]
    [[https://github.com/bitcoin/bitcoin/blob/master/test/functional/README.md][on functional tests]]

    [[https://github.com/fanquake/core-review][core review tools]]

*** Architecture
    [[https://jameso.be/dev++2018/#1][overview of arch]]

*** Bitcoin PR Review
**** #17487
    [[https://github.com/bitcoin/bitcoin/17487][pr]]
    UTXO cache is responsible for maintaining a view of the spendable coins based upon the txns in blocks. Major bottleneck during block validation.

    UTXO set currently is more than 8 GB.
    
    For this reason, UTXO cache is across several layes: on-disk and in-memory.

    The -dbcache param controls how much memory we allocate to the in-memory portion. As we validate blocks, we pull coins and we look up from disk into mem until we run out of memory.

    We completely empty the UTXO cache by writing to disk by calling CCoinsViewCache::Flush()

    We periodically flush the coins cache to avoid having to replay blocks if we shutdown improperly. 

    Once we flush the cache, we are forced to read from and write to disk for all UTXO operations, which can be notably slower depending on the underlying disk. For this reason, separating the emptying of the cache from the writing to disk might allow us to ensure durability without losing the performance benefits of maintaining the cache.

    Another case that requires writing to disk without necessarily emptying the cache can be found in the assumeutxo project. When loading a UTXO set from a serialized snapshot, it’s preferable to write out the newly constructed chainstate immediately after load to avoid having to reload the snapshot once again after a bad shutdown.

    "the main benefit of this cache is to reduce the number of unnecessary writes, i.e. when a coin is created and then destroyed we save 2 disk writes. But when we flush, even without deleting the coins from RAM, we expect 1 write if the coin is spent before the tip, otherwise no write." - sjors

    "For some reason (why?) you need to flush at the end of loading the snapshot, which normally means no coins are in RAM. This PR changes that last flush to keep stuff around."
**** #17428
     [[https://github.com/bitcoin/bitcoin/pull/17428][pr]]
**** #20477
     [[https://github.com/bitcoin/bitcoin/pull/20477][PR]]

     Broken into two commits, first moving eviction node selection logic and adding unit testing.

     [[https://bitcoincore.reviews/20477][Link to Questions]]

     My Answers:
     1. Keeps a healthy pool of new nodes. Prioritizes nodes with lower latency, better relaying capability.
     2. Attacker cannot predict which peers are protected. There are some attributes that the attack knows, but is prohibitively expensive to do. Like moving geography to lower ping time. See net.cpp SelectNodeToEvict(...)
     3. If we include these peers, then likely honest peers will be removed later on. Attacker can disconnect a bunch of peers during an inbound request. ?? - No, different threads.
     4. ASN split the network up better than subnets. IP distribution has gotten mixed up between providers. Cannoy assume IP ranges are in different parts of the world anymore. ASNs are dynamic group of IP addr range assignments based on real world entities.
     5. No, we do not reveal more than 23% of our addrman to any single peer.
     6. We can flush out some candidates.??
     7. 
     8. Unit tests 
     9. Move semantics in C++11 allow swapping pointer during copy instead. Much more efficient. If x is any type, x&& is the rvalue reference to x. x& is the lvalue reference. Rvalue reference allows compile-time branching. Any moveable object should be considered disposable.
     10. 
*** Wallet
    [[https://residency.chaincode.com/presentations/bitcoin/Wallet_Development.pdf][wallet dev presentation by John Newbery]]
    CPubKey - a public key, used to verify signatures. A point on the secp256k1 curve.
    CKey - an encapsulated private key. Used to sign data.
    CKeyID - a key identifier, which is the RIPEMD160(SHA256(pubkey))
    CTxDestination - a txout script template with a specific destination. Stored as a varint variable
     * CNoDestination: no destination set 
     * CKeyID: P2PKH
     * CScriptID: P2SH
     * WitnessV0ScriptHash
     * WitnessV0KeyHash
     * WitnessUnknown

    Wallet component is intialized through the WalletInitInterface.
    For builds with wallet, the interface is overrridden in src/wallet/init.cpp

    For --disable-wallet, there is DummyWalletInit

    initiation interface methods are called during node initialization

    During loading... WalletInit::Construct() adds a client interface to the wallet.
    Node then tells wallet to load/start/stop/etc through the ChainClient interface in src/interfaces/wallet.cpp
    Most methods in that interface call through to functions in src/wallet/load.cpp

    Node <> Wallet Interface
    Node holds a WAlletImpl interface to call functions on the wallet.
    Wallet holds a ChainImpl interface to call functions on the node.
    Notifications handler
    Node notifies the wallet about new transactions and blocks through the CValidationInterface

    Identifying Transactions
    When a transaction is added to the mempool or block is "connected", the wallet is notified through CValidationInterface.
    SyncTransaction() ... calls AddToWalletIfInvolvingMe()
    IsMine() : takes the scriptPubKey, interprets it as a Destination type, and then checks whether we have the key(s) to watch/spend.
    
    Generate Keys
    Originally a collection of unrelated private keys.
    Keypools introduced in 2010 by Satoshi. Cache 100 private keys. When a new key is needed, draw it from keypool and refresh.
    HD wallets introduced to Bitcoin Core in 2016. Keypool essentially became an address lock-ahead pool. It is used to implement a 'gap limit'.
    
    Constructing Transactions
    sendtoaddress
    sendtomany
    {create,fund,sign,send}rawtransaction
    The address is decoded into a CDestination.
    Other parameters can be added for finer control (RBF, fees, etc).
    Wallet creates the transaction in CreateTransaction(). 

    Coin Selection
    By default, coin selection is automatic.
    Logic starts in CWallet:SelectCoins().
    By preference, we choose coins with more confirmations.
    Manual coin selection (coin control) is possible in CCoinControl.

    Signing Inputs
    Last step in CreateTransaction()
    CWallet is an implementation of SigningProvider interface.
    Signing logic for the SigningProvider is all in src/script/sign.cpp.
    
    Sending Transactions
    Wallet saves and broadcats the wallet in CommitTransaction()
    submitToMemoryPool(), relayTransaction()

** CheckTemplateVerify Workshop   
** History
   /Bitcoin history and misc. trivia items./
   [[https://bitcoinmagazine.com/articles/long-road-segwit-how-bitcoins-biggest-protocol-upgrade-became-reality][history of segwit activation]]
   [[https://bitcoinmagazine.com/articles/the-battle-for-p2sh-the-untold-story-of-the-first-bitcoin-war][History of P2SH]]
** Other
   /Notes that do not fit neatly in the other categories./

   Merkelized Abstract Syntax Trees are a general concept: when bitcoin developers talk about it, they’re talking about reworking bitcoin scripts into a series of “OR” branches, and instead of the output committing to the whole script, you commit to the head of the tree.  To spend it, you only need to provide the branch of the script you’re using, and the hashes of the other branches.  This can improve privacy, and also shrink the total size of large scripts, particularly if there’s a short, common case, and a long, complex rare case.  Note that each key is 33 bytes and each signature about 72 bytes, and each merkle branch only 32 bytes.

   Sidechains are based on cross-chain consensus validation through SPV and reorganization proofs (an idea that dates back to my P2PTradeX protocol), while drivechains are based on miners being consensus proxies.

   The idea behind JoinMarket is to help create a special kind of bitcoin transaction called a CoinJoin transaction. It's aim is to improve the confidentiality and privacy of bitcoin transactions, as well as improve the capacity of the blockchain therefore reduce costs. The concept has enormous potential, but had not seen much usage despite the multiple projects that implement it. This is probably because the incentive structure was not right.
   A CoinJoin transaction requires other people to take part. The right resources (coins) have to be in the right place, at the right time, in the right quantity. This isn't a software or tech problem, its an economic problem. JoinMarket works by creating a new kind of market that would allocate these resources in the best way.

   Merged mining is the act of using work done on another block chain (the Parent) on one or more Auxiliary block chains and to accept it as valid on its own chain, using Auxiliary Proof-of-Work (AuxPoW), which is the relationship between two block chains for one to trust the other's work as their own. The Parent block chain does not need to be aware of the AuxPoW logic as blocks submitted to it are still valid blocks. 
  
*** Future directions of bitcoin 
    [[http://diyhpl.us/wiki/transcripts/2018-01-24-rusty-russell-future-bitcoin-tech-directions/][transcript]]
    Schnorr Signature Scheme
    * Has security proof, EDCSA does not.
    * Has linear property, sum of sigs is sum of keys.
    
    SIGHASH_NOINPUT - sign scripts, not txid 

    Taproot
    basic idea-> tweak pubkey Q = P+H(P,S)G
	  Q in output
	  key spend sign(Q)
	  script spend: P,S, inputs
    
    Graftroot
	  if a key exists to represent everyone
	  use delegation instead of merkle tree
	  inherently interactive key setup

*** Utreexo
    [[http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2018-10-08-utxo-accumulators-and-utreexo/][accumulators]]

*** Graftroof
    The idea of graftroot is that in every contract there is a superset of people that can spend the money. 
    In graftroot, if all the participants agree, then they can just spend. So they can do pubkey aggregation on P
    
    Taproot: P = c + H(c || script) G

    Graftroot: sigp(script)

    [[http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2018-03-06-taproot-graftroot-etc/][graftroot vs taproot]]

*** AssumeUTXO
    You get a serialized UTXO set snapshot obtained by a peer. This all hinges on a content-based hash of the UTXO set. The peer gets headers chain, ensures base of snapshot in chain, load snapshot. They want to verify the base of the snapshot or the blockhash is in the header chain. We load the snapshot which deserializes a bunch of coins and loads it into memory. Then we fake a blockchain; we have a chainstate but no blocks on disk, so it's almost like a big pruned chain. We then validate that the hash of the UTXO set matches what we expected through some hardcoded assumeutxo. This is a compiled parameter value, it can't be specified at runtime by the user which is very important. At that point, we sync the tip and that will be a similar delta to what assumevalid would be now, maybe more frequent because that would be nice. Crucially, we start background verification using a separate chainstate where we do regular initial block download, bnackfill that up to the base of the snapshot, and we compare that to the hash of the start of the snapshot and we verify that.
    [[http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-07-assumeutxo/][talk on assumeutxo]]

    [[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-April/016825.html][bitcoin-dev email]]

    The initializing node syncs the headers chain from the network, then obtains and loads one of these UTXO snapshots (i.e. a serialized version of the UTXO set bundled with the block header indicating its "base" and some other metadata).

    hardcoded hashs exist in software ..hash(utxoset). similar to assumevalid.

    snapshots can obtained in same manner as block download. Doesn't matter about source cuz of content hash.

    
*** CoinWitness
    Applications of ZK Snarks... ". Instead of embedding the rules that govern an output inside the blockchain, you'd instead embed a proof that the rules were followed. Instead of everyone checking that a transaction was permitted to be spent, they'd instead check that you checked." - Maxwell

    [[https://bitcointalk.org/index.php?topic=277389.0][coin witness]]

    "You write down a small program which verifies the faithfulness of one of these transcripts for your chosen verifiable off-chain system. The program requires that the last transaction in the transcript is special in that it pays to a Bitcoin scrippubkey/p2sh. The same address must also be provided as a public input to the program. We call this program a "witness" because it will witness the transcript and accept if and only if the transcript is valid.

    You then use the SCIP proof system to convert the program into a verifying key.  When someone wants to create a Bitcoin in an off-chain system, they pay that coin to the hash of that verifying key. People then transact in the off-chain system as they wish. To be confident that the system works faithfully they could repeat the computationally-expensive verifying key generation process to confirm that it corresponds to the transaction rules they are expecting.

    When a user of one of these coins wants to exit the system (to compact its history, to move to another system, to spend plain Bitcoins, or for any other reason), they form a final transaction paying to a Bitcoin address, and run the witness on their transcript under SCIP and produce a proof. They create a Bitcoin transaction redeeming the coin providing the proof in their script (but not the transcript, thats kept private), and the Bitcoin network validates the proof and the transaction output. The public learns nothing about the intermediate transactions, improving fungibility, but unlike other ideas which improve fungibility this idea has the potential to both improve Bitcoin's scalability and securely integrate new and innovative alternative transaction methods and expand Bitcoin's zero-trust nature to more types of transactions."

*** Covenants
    A covenant in its most general sense and historical sense, is a solemn promise to engage in or refrain from a specified action.
    [[https://bitcointalk.org/index.php?topic=278122.0][maxwell on covenants]]

    [[https://diyhpl.us/wiki/transcripts/scalingbitcoin/milan/covenants/][scaling bitcoin]]
    "Covenants can be recursively enforced down the chain for as long as you need to reinforce them. "

    "Covenants can be used to break fungibility."
    [[https://fc16.ifca.ai/bitcoin/papers/MES16.pdf][whitepaper]]

    [[https://arxiv.org/abs/2006.16714][Bitcoin Covenants: Three Ways to Control the Future]]
*** Zero Knowledge Contigent Payment
    [[https://bitcoincore.org/en/2016/02/26/zero-knowledge-contingent-payments-announcement/][zero knowledge payment]]
    ZKCP

    swapping information for value

* Footnotes

[fn:1]https://eprint.iacr.org/2018/068 
